package main

import "fmt"

/**
算法步骤
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

从空间上来看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。在最好的情况，我们要排序的表本身就是有序的，那我们的比较次数就是上面代码tmp<numbers[j-1]的比较，
因此没有移动记录，时间复杂度为O(n)。当最坏情况，即待排序表是逆序的情况，此时需要比较
,而记录的移动次数也达到最大值次。如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为𝑛2/4次。
因此，我们得出直接插入排序法的时间复杂度为O(𝑛2)。从这里也可以看出，同样的O(𝑛2)时间复杂度，直接插入排序比冒泡排序性能要好一些
*/

// 数组规模 n 较小的大多数情况下，我们可以使用插入排序，它比冒泡排序，选择排序都快，甚至比任何的排序算法都快。
func main() {
	list := []int{5}
	InsertSort(list)
	fmt.Println(list)

	list1 := []int{5, 9}
	InsertSort(list1)
	fmt.Println(list1)

	list2 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}
	InsertSort(list2)
	fmt.Println(list2)
}

func InsertSort(list []int) {
	//n := len(list)
	//// 进行 N-1 轮迭代
	//for i := 1; i <= n-1; i++ {
	//	deal := list[i] // 待排序的数
	//	j := i - 1      // 待排序的数左边的第一个数的位置
	//
	//	// 如果第一次比较，比左边的已排好序的第一个数小，那么进入处理
	//	if deal < list[j] {
	//		// 一直往左边找，比待排序大的数都往后挪，腾空位给待排序插入
	//		for ; j >= 0 && deal < list[j]; j-- {
	//			list[j+1] = list[j] // 某数后移，给待排序留空位
	//		}
	//		list[j+1] = deal // 结束了，待排序的数插入空位
	//	}
	//}

	for i := 1; i < len(list); i++ {
		tmp := list[i]
		// 从待排序序列开始比较,找到比其小的数
		j := i
		for j > 0 && tmp < list[j-1] {
			list[j] = list[j-1]
			j--
		}
		// 存在比其小的数插入
		if j != i {
			list[j] = tmp
		}
	}
}

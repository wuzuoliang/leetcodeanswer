package Code

import (
	"testing"
)

/**
给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。



示例 1：

输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
示例 2：

输入：nums = [1,1]
输出：[2]


提示：

n == nums.length
1 <= n <= 105
1 <= nums[i] <= n
进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

https://www.bilibili.com/video/BV1eg411w7gn?p=10
*/

func Test448(t *testing.T) {
	nums := []int{4, 3, 2, 7, 8, 2, 3, 1}
	t.Log(findDisappearedNumbers(nums))
}

/**
//首先，题目就是要对比一个排序号的顺序序列，查看哪些没出现，所以直接将两个数组摆出来：
   //4,3,2,7,8,2,3,1  数组1
   //1,2,3,4,5,6,7,8  数组2
   //上面是原数组，下面是序列数组；
   //遇到上面的数字，就将数组2中同样数字给替换为：替换字符（随便设置，这里可以设为*），意思就是该数字已经出现过了；
   //这样不断对照查找哪些元素出现过；则没被替换的就是没出现过的；
   //这基本是最基本的逻辑；

   //4,3,2,7,8,2,3,1

   //依次类推替换
   //1,2,3,*,5,6,7,8
   //1,2,*,*,5,6,7,8
   //1,*,*,*,5,6,7,8
   //1,*,*,*,5,6,*,8
   //1,*,*,*,5,6,*,*
   //1,*,*,*,5,6,*,*  位置2已经替换过,不用再替换；
   //1,*,*,*,5,6,*,*  位置3已经替换过,不用再替换；
   //*,*,*,*,5,6,*,*  此时5，6没被替换，说明5，6在数组1中没出现过；

   //但这样的替换需要额外用一个序列数组（1到n)，
   //所以才有用自身数组元素的负数作为替换字符的方法，这样被替换字符也可以继续作为索引值使用；节省了一个数组空间；
*/
func findDisappearedNumbers(nums []int) []int {

	n := len(nums)
	for _, v := range nums {
		v = (v - 1) % n
		nums[v] += n
	}
	var ans []int
	for i, v := range nums {
		if v <= n {
			ans = append(ans, i+1)
		}
	}
	return ans
}
